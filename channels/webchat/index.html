<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HomeClaw WebChat</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: system-ui, sans-serif; max-width: 600px; margin: 1rem auto; padding: 0 1rem; }
    h1 { font-size: 1.25rem; }
    .meta { font-size: 0.85rem; color: #666; margin-bottom: 0.5rem; }
    #log { border: 1px solid #ccc; min-height: 200px; max-height: 50vh; padding: 0.5rem; margin: 0.5rem 0; overflow-y: auto; font-size: 0.9rem; }
    #log .user { color: #06c; }
    #log .bot { color: #080; }
    #log .sys { color: #666; }
    #log .error { color: #b71c1c; }
    .input-row { display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin: 0.5rem 0; }
    #user_id { width: 120px; padding: 0.5rem; }
    #msg { flex: 1; min-width: 120px; padding: 0.5rem; }
    #files { font-size: 0.85rem; }
    button { padding: 0.5rem 1rem; cursor: pointer; }
    .status { font-size: 0.85rem; color: #666; margin-bottom: 0.5rem; }
  </style>
</head>
<body>
  <h1>HomeClaw WebChat</h1>
  <p class="meta">Chat with HomeClaw. Ensure <code>user_id</code> exists in <code>config/user.yml</code> (e.g. <code>webchat_user</code>).</p>
  <p class="status" id="status">Loading config…</p>
  <div id="log"></div>
  <div id="input" class="input-row" style="display:none;">
    <select id="conversation_type" title="Assistant = main chat; Friend = Friends plugin (session_id=friend)">
      <option value="assistant">Assistant</option>
      <option value="friend">Friend</option>
    </select>
    <input type="text" id="user_id" placeholder="user_id" title="Must exist in config/user.yml">
    <input type="text" id="msg" placeholder="Type a message…" autocomplete="off">
    <input type="file" id="files" multiple accept="image/*,video/*,audio/*,*/*" title="Attach images, video, audio, or files">
    <button id="send">Send</button>
    <button id="sync_kb" title="Sync knowledge base folder for selected user">Sync KB</button>
  </div>
  <script>
    (function() {
      const logEl = document.getElementById('log');
      const statusEl = document.getElementById('status');
      const inputWrap = document.getElementById('input');
      const msgInput = document.getElementById('msg');
      const userIdInput = document.getElementById('user_id');
      const filesInput = document.getElementById('files');
      const sendBtn = document.getElementById('send');
      const syncKbBtn = document.getElementById('sync_kb');

      function addLog(cls, text) {
        const p = document.createElement('p');
        p.className = cls;
        p.textContent = text;
        logEl.appendChild(p);
        logEl.scrollTop = logEl.scrollHeight;
      }

      let ws = null;
      let config = { ws_url: '', user_id: 'webchat_user' };

      function connect() {
        if (!config.ws_url) return;
        statusEl.textContent = 'Connecting…';
        ws = new WebSocket(config.ws_url);
        ws.onopen = function() {
          statusEl.textContent = 'Connected. Send a message.';
          inputWrap.style.display = 'flex';
          addLog('sys', 'Connected to Core.');
        };
        ws.onclose = function() {
          statusEl.textContent = 'Disconnected. Refresh to reconnect.';
          addLog('sys', 'Disconnected.');
        };
        ws.onerror = function() {
          statusEl.textContent = 'Connection error. Is Core running?';
        };
        ws.onmessage = function(ev) {
          try {
            const data = JSON.parse(ev.data);
            if (data.error) addLog('error', 'Error: ' + data.error);
            else if (data.text) addLog('bot', data.text);
          } catch (e) {
            addLog('bot', ev.data);
          }
        };
      }

      function mediaKind(type) {
        if (!type) return 'file';
        type = type.toLowerCase();
        if (type.startsWith('image/')) return 'image';
        if (type.startsWith('video/')) return 'video';
        if (type.startsWith('audio/')) return 'audio';
        return 'file';
      }

      sendBtn.addEventListener('click', send);
      msgInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') send();
      });
      if (syncKbBtn) {
        syncKbBtn.addEventListener('click', async function() {
          const user_id = (userIdInput && userIdInput.value ? userIdInput.value : config.user_id || '').trim();
          if (!user_id) {
            addLog('sys', 'Select a user_id first.');
            return;
          }
          syncKbBtn.disabled = true;
          addLog('sys', 'Syncing knowledge base for ' + user_id + '…');
          try {
            const r = await fetch(location.origin + '/api/knowledge_base/sync_folder?user_id=' + encodeURIComponent(user_id));
            const data = await r.json().catch(function() { return {}; });
            if (r.ok && data.ok) {
              addLog('sys', 'KB sync: ' + (data.message || '') + ' (added: ' + (data.added || 0) + ', removed: ' + (data.removed || 0) + ')');
            } else {
              addLog('error', 'KB sync failed: ' + (data.detail || data.message || r.status));
            }
          } catch (e) {
            addLog('error', 'KB sync error: ' + e.message);
          }
          syncKbBtn.disabled = false;
        });
      }

      async function send() {
        const user_id = (userIdInput && userIdInput.value ? userIdInput.value : config.user_id || '').trim();
        const text = (msgInput.value || '').trim();
        const fileList = filesInput && filesInput.files ? Array.from(filesInput.files) : [];
        if (!user_id || (!text && fileList.length === 0)) return;
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          addLog('sys', 'Not connected.');
          return;
        }
        if (text) addLog('user', 'You: ' + text);
        if (fileList.length) addLog('user', 'You: ' + fileList.length + ' file(s)');
        msgInput.value = '';
        filesInput.value = '';

        const conversationType = (document.getElementById('conversation_type') && document.getElementById('conversation_type').value) || 'assistant';
      const payload = { user_id: user_id, text: text || '(no text)' };
      if (conversationType === 'friend') {
        payload.session_id = 'friend';
        payload.conversation_type = 'friend';
        payload.channel_name = 'friend';
      } else {
        payload.channel_name = 'companion';
      }
      try {
        var pos = await new Promise(function(res, rej) {
          if (!navigator.geolocation) { rej(new Error('no geolocation')); return; }
          navigator.geolocation.getCurrentPosition(function(p) { res(p); }, rej, { timeout: 5000, maximumAge: 60000 });
        });
        if (pos && pos.coords) payload.location = pos.coords.latitude + ',' + pos.coords.longitude;
        } catch (_) {}
        if (fileList.length === 0) {
          ws.send(JSON.stringify(payload));
          return;
        }

        var imageFiles = [];
        var otherFiles = [];
        for (var i = 0; i < fileList.length; i++) {
          var file = fileList[i];
          var k = mediaKind(file.type);
          if (k === 'file') {
            var dataUrl = await new Promise(function(res, rej) {
              var r = new FileReader();
              r.onload = function() { res(r.result); };
              r.onerror = rej;
              r.readAsDataURL(file);
            });
            var s = String(dataUrl).trim().toLowerCase().replace(/^data:\s/, 'data:');
            if (s.startsWith('data:image/')) k = 'image';
            else if (s.startsWith('data:video/')) k = 'video';
            else if (s.startsWith('data:audio/')) k = 'audio';
          }
          if (k === 'image') imageFiles.push(file);
          else otherFiles.push({ file: file, kind: k });
        }

        if (imageFiles.length > 0) {
          try {
            var form = new FormData();
            imageFiles.forEach(function(f) { form.append('files', f); });
            var r = await fetch(location.origin + '/api/upload', { method: 'POST', body: form });
            var data = await r.json().catch(function() { return {}; });
            if (r.ok && Array.isArray(data.paths) && data.paths.length > 0) {
              payload.images = data.paths;
            } else {
              var urls = await Promise.all(imageFiles.map(function(f) {
                return new Promise(function(res, rej) {
                  var reader = new FileReader();
                  reader.onload = function() { res(reader.result); };
                  reader.onerror = rej;
                  reader.readAsDataURL(f);
                });
              }));
              payload.images = urls;
            }
          } catch (e) {
            var urls = await Promise.all(imageFiles.map(function(f) {
              return new Promise(function(res, rej) {
                var reader = new FileReader();
                reader.onload = function() { res(reader.result); };
                reader.onerror = rej;
                reader.readAsDataURL(f);
              });
            }));
            payload.images = urls;
          }
        }

        var videos = [], audios = [], files = [];
        for (var j = 0; j < otherFiles.length; j++) {
          var item = otherFiles[j];
          var dataUrl = await new Promise(function(res, rej) {
            var reader = new FileReader();
            reader.onload = function() { res(reader.result); };
            reader.onerror = rej;
            reader.readAsDataURL(item.file);
          });
          if (item.kind === 'video') videos.push(dataUrl);
          else if (item.kind === 'audio') audios.push(dataUrl);
          else files.push(dataUrl);
        }
        if (videos.length) payload.videos = videos;
        if (audios.length) payload.audios = audios;
        if (files.length) payload.files = files;
        ws.send(JSON.stringify(payload));
      }

      fetch('/config')
        .then(function(r) { return r.json(); })
        .then(function(cfg) {
          config = cfg;
          if (userIdInput) userIdInput.value = cfg.user_id || 'webchat_user';
          connect(cfg.ws_url);
        })
        .catch(function() {
          statusEl.textContent = 'Could not load config. Set core_host/core_port or CORE_URL in channels/.env.';
        });
    })();
  </script>
</body>
</html>
